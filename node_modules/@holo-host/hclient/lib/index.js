"use strict";
/**
 * The javascript library for making your web UI Holo enabled!
 *
 * It handles:
 * - Key management and generation
 *   - Generating temporary readonly keys for browsing
 *   - Detecting when authorization is required and prompting the user to signup/login to generate read/write keys
 * - Signing calls and responses
 * - Setting up a websocket connection to the interceptor to sign commits on request
 * - Wrapping and unwrapping calls to and from the interceptor such that they look like regular holochain calls
 *
 * Using this library to make a Holochain web UI Holo compatible is very easy provided you are already using hc-web-client
 * to connect to holochain. In this case an app can be converted by adding the following lines to a page load function
 * ```javascript
 * let holochainclient = require('@holochain/hc-web-client') // this should already be part of your web UI
 * const hClient = require('hClient')
 *
 * holochainclient = hClient.makeWebClient(holochainclient) // overwrite the holochain client with the holo version
 * hClient.installLoginDialog() // add the optional login dialog (strongly reccomended)
 * ```
 *
 * The login dialog is required because for Holo the user must manage their own keys in the browser. This is unlike Holochain where they
 * are managed by the conductor. If the login dialog is installed hClient will automatically detect when a user is trying to take an action that
 * requires a keypair (such as making a commit) and modally display the login page. Completing the login will generate/regenerate the users keypair
 * that is stored in the browser.
 *
 * ![holo-login-dialog](./sign-in-to-holo-screen.png?raw=true "Login Dialog")
 *
 * @module hClient
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var hClient = (function () {
    var _this = this;
    var keypair;
    var websocket;
    var _happId;
    var _a = require('./keyManagement'), generateReadonlyKeypair = _a.generateReadonlyKeypair, generateNewReadwriteKeypair = _a.generateNewReadwriteKeypair, regenerateReadwriteKeypair = _a.regenerateReadwriteKeypair;
    var _b = require('./login'), showLoginDialog = _b.showLoginDialog, insertLoginHtml = _b.insertLoginHtml, registerLoginCallbacks = _b.registerLoginCallbacks;
    var _c = require('./resolver'), getHashForUrl = _c.getHashForUrl, getHostsForUrl = _c.getHostsForUrl;
    var toBase64 = require('./dpki-ultralite').toBase64;
    var Encoding = require('@holochain/hcid-js').Encoding;
    /* ============================================
    =            Public API Functions            =
    ============================================ */
    /**
     * Insert the HTML for the login dialog into the current document and register the callbacks
     * @method
     * @memberof module:hClient
     *
     * @return     {(Function|Object)}  { description_of_the_return_value }
     */
    var installLoginDialog = function () {
        insertLoginHtml();
        registerLoginCallbacks();
    };
    /**
     * Displays the login dialog and generates a new read/write key with the email/password
     * This will overwrite the current key
     * @memberof module:hClient
     */
    var triggerLoginPrompt = function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, email, password, newRegistration;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, showLoginDialog()];
                case 1:
                    _a = _b.sent(), email = _a.email, password = _a.password, newRegistration = _a.newRegistration;
                    return [2 /*return*/, startLoginProcess(email, password, newRegistration)];
            }
        });
    }); };
    /**
     * Start the local key generation/regeneration process with an email and password
     *
     * @param      {string}           email     The email
     * @param      {string}           password  The password
     * @param      {boolean}          newRegistration If true then register new salt with the saltservice otherwise try and regenerate existing keys
     * @memberof module:hClient
     */
    var startLoginProcess = function (email, password, newRegistration) { return __awaiter(_this, void 0, void 0, function () {
        var kp;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!newRegistration) return [3 /*break*/, 2];
                    console.log('registering new email with salt service');
                    return [4 /*yield*/, generateNewReadwriteKeypair(email, password)];
                case 1:
                    kp = _a.sent();
                    return [3 /*break*/, 4];
                case 2:
                    console.log('restoring keys from existing registration');
                    return [4 /*yield*/, regenerateReadwriteKeypair(email, password)];
                case 3:
                    kp = _a.sent();
                    _a.label = 4;
                case 4:
                    console.log('keypair is ', kp);
                    return [4 /*yield*/, setKeypair(kp)];
                case 5:
                    _a.sent();
                    return [4 /*yield*/, requestHosting()];
                case 6:
                    _a.sent();
                    return [2 /*return*/, true];
            }
        });
    }); };
    /**
     * Wraps and returns a holochainClient module.
     * Keeps the same functionaltiy but adds preCall and postCall hooks and also forces
     * connect to go to a given URL. This is the essential requirement to holo-fy any holochain web UI.
     * @memberof module:hClient
     *
     * @param      {Object}    holochainClient       A hc-web-client module to wrap
     *
     * @param      {Object}    [optionals]           Non-required arguments
     * @param      {string}    [optionals.happId]    Override the happId; mostly for testing purposes. Defaults to using the hApp identifier that Holo has linked to this application (this is the HHA address of the entry storing the hApp bundle and happ DNS info).
     * @param      {string}    [optionals.hAppUrl]   Override the hAppUrl that is passed in the call to the resolver to get the host tranche (the associated DNS). Defaults to using window.location.origin
     * @param      {string}    [optionals.hostUrl]   Override the host tranche resolution process and call this host url directly. Defaults to calling the resolver with the resolverOrigin and using the first host URL it returns
     * @param      {Function}  [optionals.preCall]   The pre call funciton. Takes the callString and params and returns new callString and params.
     * Leave as default unless you know what you are doing.
     *
     * @param      {Function}  [optionals.postCall]  The post call function. Takes the response and returns the new response.
     * Leave as default unless you know what you are doing.
     *
     * @param      {Function}  [optionals.postConnect]  The post connect function.
     * Takes a RPC-websockets object and returns it preCall=preCall, postCall=postCall, postConnect=postConnect.
     * Leave as default unless you know what you are doing.
     */
    var makeWebClient = function (holochainClient, optionals) {
        if (optionals === void 0) { optionals = {}; }
        return __awaiter(_this, void 0, void 0, function () {
            var hostUrl, HappBundleDNS, HappBundleHash, HappBundleDNS, preCall, postCall, postConnect;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(optionals.hostUrl === undefined)) return [3 /*break*/, 2];
                        HappBundleDNS = optionals.hAppUrl || window.location.origin;
                        HappBundleHash = optionals.happId || null;
                        return [4 /*yield*/, getHostForUrl(HappBundleDNS, HappBundleHash)];
                    case 1:
                        hostUrl = _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        hostUrl = optionals.hostUrl;
                        _a.label = 3;
                    case 3:
                        if (!(optionals.happId && optionals.happId !== undefined)) return [3 /*break*/, 4];
                        _happId = optionals.happId;
                        return [3 /*break*/, 6];
                    case 4:
                        HappBundleDNS = optionals.hAppUrl || window.location.origin;
                        return [4 /*yield*/, getHashForUrl(HappBundleDNS)];
                    case 5:
                        _happId = _a.sent();
                        _a.label = 6;
                    case 6:
                        preCall = optionals.preCall || _preCall;
                        postCall = optionals.postCall || _postCall;
                        postConnect = optionals.postConnect || _postConnect;
                        return [2 /*return*/, {
                                connect: function () { return holochainClient.connect(hostUrl).then(function (_a) {
                                    var call = _a.call, close = _a.close, ws = _a.ws;
                                    return __awaiter(_this, void 0, void 0, function () {
                                        var _this = this;
                                        return __generator(this, function (_b) {
                                            switch (_b.label) {
                                                case 0: return [4 /*yield*/, postConnect(ws)];
                                                case 1:
                                                    ws = _b.sent();
                                                    return [2 /*return*/, {
                                                            call: function () {
                                                                var callStringSegments = [];
                                                                for (var _i = 0; _i < arguments.length; _i++) {
                                                                    callStringSegments[_i] = arguments[_i];
                                                                }
                                                                return function (params) { return __awaiter(_this, void 0, void 0, function () {
                                                                    var callString, _a, newCallString, newParams;
                                                                    return __generator(this, function (_b) {
                                                                        switch (_b.label) {
                                                                            case 0:
                                                                                callString = callStringSegments.length === 1 ? callStringSegments[0] : callStringSegments.join('/');
                                                                                return [4 /*yield*/, preCall(callString, params)];
                                                                            case 1:
                                                                                _a = _b.sent(), newCallString = _a.callString, newParams = _a.params;
                                                                                return [2 /*return*/, call(newCallString)(newParams).then(postCall)];
                                                                        }
                                                                    });
                                                                }); };
                                                            },
                                                            callZome: function (_instanceId, zome, func) { return function (params) { return __awaiter(_this, void 0, void 0, function () {
                                                                var callString, _a, newCallString, newParams;
                                                                return __generator(this, function (_b) {
                                                                    switch (_b.label) {
                                                                        case 0:
                                                                            callString = [_instanceId, zome, func].join('/');
                                                                            return [4 /*yield*/, preCall(callString, params)];
                                                                        case 1:
                                                                            _a = _b.sent(), newCallString = _a.callString, newParams = _a.params;
                                                                            return [2 /*return*/, call(newCallString)(newParams).then(postCall)];
                                                                    }
                                                                });
                                                            }); }; },
                                                            close: close,
                                                            ws: ws
                                                        }];
                                            }
                                        });
                                    });
                                }); }
                            }];
                }
            });
        });
    };
    /**
     * Set overrides for the key generation function
     * Useful for testing or providing your own key management
     * @memberof module:hClient
     *
     * @param      {Object} keyManagementCallbacks
     * @param      {generateReadonlyKeypair} keyManagementCallbacks.generateReadonlyKeypair
     * @param      {generateNewReadwriteKeypair} keyManagementCallbacks.generateNewReadwriteKeypair
     * @param      {regenerateReadwriteKeypair} keyManagementCallbacks.regenerateReadwriteKeypair
     */
    var setKeyManagementFunctions = function (overrides) {
        if (overrides.generateReadonlyKeypair) {
            generateReadonlyKeypair = overrides.generateReadonlyKeypair;
        }
        if (overrides.generateNewReadwriteKeypair) {
            generateNewReadwriteKeypair = overrides.generateNewReadwriteKeypair;
        }
        if (overrides.regenerateReadwriteKeypair) {
            regenerateReadwriteKeypair = overrides.regenerateReadwriteKeypair;
        }
    };
    /**
     * Gets the current agent identifier from the current key pair
     * @memberof module:hClient
     *
     * @return     {(Encoding|Object)}  The current agent identifier.
     */
    var getCurrentAgentId = function () { return __awaiter(_this, void 0, void 0, function () {
        var enc;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!keypair) return [3 /*break*/, 2];
                    return [4 /*yield*/, new Encoding('hcs0')];
                case 1:
                    enc = _a.sent();
                    return [2 /*return*/, enc.encode(keypair._signPub)];
                case 2: return [2 /*return*/, undefined];
            }
        });
    }); };
    /**
     * Request that the Holo host currently serving the page sets up a local chain for the current keypair
     * @memberof module:hClient
     *
     */
    var requestHosting = function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, _b, _c, _d;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    if (!websocket) return [3 /*break*/, 2];
                    _b = (_a = websocket).call;
                    _c = ['holo/agents/new'];
                    _d = {};
                    return [4 /*yield*/, getCurrentAgentId()];
                case 1: return [2 /*return*/, _b.apply(_a, _c.concat([(_d.agentId = _e.sent(),
                            _d.happId = _happId,
                            _d)]))];
                case 2: throw Error('Cannot request registration with no websocket');
            }
        });
    }); };
    /* =====  End of Public API Functions  ====== */
    /**
     * Calls the resolver with the given url and returns the first host in the tranche
     *
     * @return     {Object}  The websocket url to a host
     */
    var getHostForUrl = function (url, happId) { return __awaiter(_this, void 0, void 0, function () {
        var hosts, hhaHappId, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, getHostsForUrl(url)];
                case 1:
                    hosts = _b.sent();
                    _a = _happId || happId;
                    if (_a) return [3 /*break*/, 3];
                    return [4 /*yield*/, getHashForUrl(url)];
                case 2:
                    _a = (_b.sent());
                    _b.label = 3;
                case 3:
                    hhaHappId = _a;
                    return [2 /*return*/, 'ws://' + hhaHappId + '.' + hosts[0]];
            }
        });
    }); };
    // const getDefaultWebsocketUrl = () => document.getElementsByTagName('base')[0].href.replace('http', 'ws')
    /**
     * Setter for the keypair
     * Attaches a new event listener on the websocket for the new agentID
     *
     * @param      {Keypair}  kp      dpki-lite keypair object to attach to the instance
     */
    var setKeypair = function (kp) { return __awaiter(_this, void 0, void 0, function () {
        var agentId, event_1;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    keypair = kp;
                    if (!websocket) return [3 /*break*/, 3];
                    return [4 /*yield*/, getCurrentAgentId()];
                case 1:
                    agentId = _a.sent();
                    return [4 /*yield*/, websocket.call('holo/identify', { agentId: agentId })
                        // set up the websocket to sign on request
                    ];
                case 2:
                    _a.sent();
                    event_1 = "agent/" + agentId + "/sign";
                    console.log('subscribing to event', event_1);
                    websocket.subscribe(event_1);
                    websocket.on(event_1, function (_a) {
                        var entry = _a.entry, id = _a.id;
                        return __awaiter(_this, void 0, void 0, function () {
                            var signature, signatureBase64;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0: return [4 /*yield*/, keypair.sign(entry)];
                                    case 1:
                                        signature = _b.sent();
                                        return [4 /*yield*/, toBase64(signature)];
                                    case 2:
                                        signatureBase64 = _b.sent();
                                        websocket.call('holo/clientSignature', {
                                            signature: signatureBase64,
                                            requestId: id
                                        });
                                        return [2 /*return*/];
                                }
                            });
                        });
                    });
                    return [3 /*break*/, 4];
                case 3: throw Error('Could not register callback as no valid websocket instance found');
                case 4: return [2 /*return*/];
            }
        });
    }); };
    /**
     * Preprocesses the callString and params before making a call
     *
     * @param      {string}  callString  The call string e.g. dna/zome/function
     * @param      {Object}  params      The parameters
     * @return     {Object}  The updated callString and params passed to call
     */
    var _preCall = function (callString, params) { return __awaiter(_this, void 0, void 0, function () {
        var _a, instanceId, zome, funcName, call, signature, signatureBase64, callParams, _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (!!keypair) return [3 /*break*/, 1];
                    throw new Error('trying to call with no keys');
                case 1:
                    // WARNING: The follow console will return ALL KEY DATA, including private keys and Uint8Arrays... TODO: REMOVE this console once debugging / review of keys is no longer necessary.
                    // console.log('call will be signed with', keypair)
                    console.log('hClient ACTION: Making call and signing with pub keypair.');
                    _a = __read(callString.split('/'), 3), instanceId = _a[0], zome = _a[1], funcName = _a[2];
                    call = {
                        method: callString,
                        params: params
                    };
                    return [4 /*yield*/, keypair.sign(JSON.stringify(call))];
                case 2:
                    signature = _c.sent();
                    return [4 /*yield*/, toBase64(signature)];
                case 3:
                    signatureBase64 = _c.sent();
                    _b = {};
                    return [4 /*yield*/, getCurrentAgentId()];
                case 4:
                    callParams = (_b.agentId = _c.sent(),
                        _b.happId = _happId,
                        _b.instanceId = instanceId,
                        _b.zome = zome,
                        _b.function = funcName,
                        _b.args = params,
                        _b.signature = signatureBase64,
                        _b);
                    return [2 /*return*/, { callString: 'holo/call', params: callParams }];
            }
        });
    }); };
    /**
     * Postprocess the response of a call before returning it to the UI
     *
     * @param      {string}  response  The response of the call
     * @return     {string}  Updated response
     */
    var _postCall = function (response) {
        console.log(response);
        // Check response for authentication error to see if login is required
        try {
            var responseJson = JSON.parse(response);
            if (responseJson.Err && responseJson.Err.code === 401) {
                triggerLoginPrompt();
            }
        }
        catch (e) {
            console.log(e);
        }
        // TODO: Sign the response and sent it back to the interceptor (check this is still required)
        // const responseSig = keypair.sign()
        return response;
    };
    /**
     * Add any new callbacks to the websocket object or make calls immediatly after connecting
     *
     * @param      {Object}  ws      { rpc=websockets object }
     */
    var _postConnect = function (ws) { return __awaiter(_this, void 0, void 0, function () {
        var kp;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    websocket = ws;
                    console.log('generating readonly keypair');
                    return [4 /*yield*/, generateReadonlyKeypair()];
                case 1:
                    kp = _a.sent();
                    return [4 /*yield*/, setKeypair(kp)];
                case 2:
                    _a.sent();
                    return [2 /*return*/, ws];
            }
        });
    }); };
    return {
        installLoginDialog: installLoginDialog,
        triggerLoginPrompt: triggerLoginPrompt,
        startLoginProcess: startLoginProcess,
        makeWebClient: makeWebClient,
        getCurrentAgentId: getCurrentAgentId,
        requestHosting: requestHosting,
        getHashForUrl: getHashForUrl,
        getHostsForUrl: getHostsForUrl,
        setKeyManagementFunctions: setKeyManagementFunctions,
        keyManagement: require('./keyManagement'),
        dpkiUltralite: require('./dpki-ultralite')
    };
})();
module.exports = hClient;
