"use strict";
/* eslint-disable */
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Output `count` random bytes
 * @example
 * const bytes = sodium.random.bytes(32)
 *
 * @param {number} count - number of random bytes to output
 * @return {Buffer}
 */
var index_1 = require("./index");
var _sodium = require('libsodium-wrappers-sumo');
var msgpack = require('msgpack-lite');
function randomBytes(count) {
    return new Promise(function (resolve, reject) {
        _sodium.ready.then(function (_) {
            resolve(_sodium.randombytes_buf(count));
            reject('failure reason'); // rejected
        });
    });
}
exports.randomBytes = randomBytes;
exports.randomBytes = randomBytes;
/**
 * using base64url encoding (https://tools.ietf.org/html/rfc4648#section-5)
 * Generate an identity string with a pair of public keys
 * @param {Buffer} signPub - singing public key
 * @param {Buffer} encPub - encryption public key
 * @return {string} - the base64url encoded identity (with checksum)
 */
function encodeId(signPub, encPub) {
    return new Promise(function (resolve, reject) {
        _sodium.ready.then(function (_) {
            resolve(_sodium.to_base64(new Uint8Array(__spread(signPub, encPub))));
            reject('failure reason'); // rejected
        });
    });
}
exports.encodeId = encodeId;
exports.encodeId = encodeId;
/**
 * using base64url encoding (https://tools.ietf.org/html/rfc4648#section-5)
 * break an identity string up into a pair of public keys
 * @param {string} id - the base64url encoded identity string
 * @return {object} - { signPub: Buffer, encPub: Buffer }
 */
function decodeId(id) {
    return new Promise(function (resolve, reject) {
        _sodium.ready.then(function (sodium) {
            var tmp = _sodium.from_base64(id);
            resolve({
                signPub: tmp.slice(0, 32),
                encPub: tmp.slice(32, 64)
            });
            reject('failure reason');
        });
    });
}
exports.decodeId = decodeId;
exports.decodeId = decodeId;
/**
 * verify a signature given the original data, and the signer's identity string
 * @param {Buffer} signature - the binary signature
 * @param {Buffer} data - the binary data to verify
 * @param {string} signerId - the signer's public identity string
 */
function verify(signature, data, signerId) {
    return new Promise(function (resolve, reject) {
        decodeId(signerId).then(function (pw) {
            var signPub = pw.signPub;
            _sodium.ready.then(function (sodium) {
                resolve(_sodium.crypto_sign_verify_detached(signature, data, signPub));
                reject('failure reason');
            });
        });
    });
}
exports.verify = verify;
exports.verify = verify;
/**
 * simplify the api for generating a password hash with our set parameters
 * @param {Buffer} pass - the password buffer to hash
 * @param {Buffer} [salt] - if specified, hash with this salt (otherwise random)
 * @return {object} - { salt: Buffer, hash: Buffer }
 */
function pwHash(pass, salt) {
    return new Promise(function (resolve, reject) {
        _sodium.ready.then(function (_) {
            var opt = {
                opslimit: _sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE,
                memlimit: _sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE,
                algorithm: _sodium.crypto_pwhash_ALG_ARGON2ID13,
                keyLength: 32,
                salt: salt || _sodium.randombytes_buf(index_1.SALTBYTES)
            };
            var derivedKey = _sodium.crypto_pwhash(opt.keyLength, pass, opt.salt, opt.opslimit, opt.memlimit, opt.algorithm);
            resolve({
                salt: opt.salt,
                hash: derivedKey
            });
            reject('failure reason');
        });
    });
}
exports.pwHash = pwHash;
exports.pwHash = pwHash;
/**
 * Helper for encrypting a buffer with a pwhash-ed passphrase
 * @param {Buffer} data
 * @param {string} passphrase
 * @return {Buffer} - the encrypted data
 */
function pwEnc(data, passphrase, adata) {
    return new Promise(function (resolve, reject) {
        _sodium.ready.then(function (_) {
            pwHash(passphrase).then(function (pw) {
                var salt = pw.salt;
                var secret = pw.hash;
                var nonce = _sodium.randombytes_buf(index_1.NONCEBYTES);
                var ciphertext = _sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(data, adata || null, null, nonce, secret);
                resolve(msgpack.encode({
                    salt: salt,
                    nonce: nonce,
                    cipher: ciphertext
                }));
                reject('failure reason');
            });
        });
    });
}
exports.pwEnc = pwEnc;
exports.pwEnc = pwEnc;
/**
 * Helper for decrypting a buffer with a pwhash-ed passphrase
 * @param {Buffer} data
 * @param {string} passphrase
 * @return {Buffer} - the decrypted data
 */
function pwDec(data, passphrase, adata) {
    var decodedData = msgpack.decode(data);
    return new Promise(function (resolve, reject) {
        pwHash(passphrase, decodedData.salt).then(function (pw) {
            var secret = pw.hash;
            _sodium.ready.then(function (_) {
                resolve(_sodium.crypto_aead_xchacha20poly1305_ietf_decrypt(null, decodedData.cipher, adata || null, decodedData.nonce, secret));
                reject('failure reason'); // rejected
            });
        });
    });
}
exports.pwDec = pwDec;
exports.pwDec = pwDec;
/**
 * Convert a buffer to a base64 encoded string.
 * Uses the URL safe no padding option
 *
 * @param      {Buffer}  buffer  The data to encode
 * @return     {string}  base64 encoded string
 */
function toBase64(buffer) {
    return _sodium.ready.then(function (_) {
        return _sodium.to_base64(buffer, _sodium.base64_variants.ORIGINAL);
    });
}
exports.toBase64 = toBase64;
exports.toBase64 = toBase64;
/**
 * Convert a base64 encoded string to a buffer
 * Uses the URL safe no padding option
 *
 * @param      {string}  str  The base64 encoded string
 * @return     {Buffer}  base64 encoded string
 */
function fromBase64(str) {
    return _sodium.ready.then(function (_) {
        return _sodium.from_base64(str, _sodium.base64_variants.ORIGINAL);
    });
}
exports.fromBase64 = fromBase64;
exports.fromBase64 = fromBase64;
